# Warn user if genes have been filtered
if(sum(!pass_filter) > 0){
warning(paste("There were", sum(!pass_filter),
"genes either with lengths not multiples of 3 or not above length threshold (default 240bp), these genes have been ignored"))
}
if(sum(ambiguous_bases) > 0){
warning(paste("There were", sum(ambiguous_bases),
"genes with ambiguous bases, these genes have been ignored"))
}
if(sum(highly_expressed) == 0){
stop("No highly expressed genes after filtering, unable to compute growth rate")
}
return(list(Genes=genes,
HE = highly_expressed,
Filtered = sum(ambiguous_bases)+sum(!pass_filter),
Depth = depth_of_coverage))
}
boxcoxTransform <- function(x, lambda, back_transform = F) {
if (back_transform == TRUE) {
(x*lambda +1)^(1/lambda)  %>% return()
} else {
(((x^lambda) - 1) / lambda) %>% return()
}
}
countCodonPairs <- function(codon_vec){
codon_pairs <- data.frame(C1=codon_vec[1:(length(codon_vec) - 1)],
C2=codon_vec[2:(length(codon_vec))],
stringsAsFactors = F)
codon_pairs$P <- paste(codon_pairs$C1, codon_pairs$C2, sep = "-")
codon_pairs <- codon_pairs %>% group_by(P) %>% dplyr::count()
codon_pairs$Codon1 <- codon_pairs$P %>% gsub(pattern = "-.*", replace = "")
codon_pairs$Codon2 <- codon_pairs$P %>% gsub(pattern = ".*-", replace = "")
return(codon_pairs)
}
getAA <- function(codon_pairs, genetic_code = "11"){
codon_pairs$AA1 <- codon_pairs$Codon1 %>% DNAStringSet() %>%
translate(genetic.code = getGeneticCode(id_or_name2=genetic_code)) %>%
as.character()
codon_pairs$AA2 <- codon_pairs$Codon2 %>% DNAStringSet() %>%
translate(genetic.code = getGeneticCode(id_or_name2=genetic_code)) %>%
as.character()
codon_pairs$PAA <- paste(codon_pairs$AA1, codon_pairs$AA2, sep="-")
return(codon_pairs)
}
getPairCounts <- function(genes, genetic_code = "11"){
genome <- unlist(genes)
#Group Nucleotides into codons
codon_vec <- genome %>% codons() %>% as.character()
#Get AA
aa_vec <- translate(genome,
genetic.code = getGeneticCode(id_or_name2=genetic_code)) %>%
as.character() %>% strsplit(split="") %>% unlist()
#Table of codon pair counts w/ columns for Codon and AA ids
count_tbl <- codon_vec %>% countCodonPairs() %>%
getAA(.,genetic_code = genetic_code) %>% as.data.frame(stringsAsFactors = F)
count_tbl$n <- as.numeric(count_tbl$n)
#Single codon couns
codon_tbl <- table(codon_vec)
#Single aa counts
aa_tbl <- table(aa_vec)
#aa pair counts
aa_pair_tbl <- count_tbl %>% subset(select = c(PAA,n)) %>%
group_by(PAA) %>% summarise(PAA_n = sum(n)) %>%
as.data.frame(stringsAsFactors = F)
rownames(aa_pair_tbl) <- aa_pair_tbl$PAA
#Attach other counts to codon pair counts
count_tbl$Codon1_n <- codon_tbl[count_tbl$Codon1] %>% as.numeric()
count_tbl$Codon2_n <- codon_tbl[count_tbl$Codon2] %>% as.numeric()
count_tbl$AA1_n <- aa_tbl[count_tbl$AA1] %>% as.numeric()
count_tbl$AA2_n <- aa_tbl[count_tbl$AA2] %>% as.numeric()
count_tbl$PAA_n <- aa_pair_tbl[count_tbl$PAA,"PAA_n"] %>% as.numeric()
return(count_tbl)
}
getCPB <- function(count_tbl){
count_tbl <- count_tbl %>%
mutate(CPS = log(n / (PAA_n * (Codon1_n * Codon2_n) / (AA1_n * AA2_n))))
CPB <- sum(count_tbl$CPS) / (nrow(count_tbl) - 1)
return(CPB)
}
#' Predict Growth Rate
#'
#' This function predicts the growth rate of prokaryotic or eukaryotic organisms based on
#' genomic codon usage patterns (Weissman et. al. 2021; Weissman et al. TBD).
#'
#' @param genes DNAStringSet object holding all in-frame coding sequences (nucleotide sequences)
#'  from a genome. See Biostrings package.
#' @param highly_expressed Logical vector describing the set of highly expressed
#' genes. Must be of same length as \code{genes}. Typically these are ribosomal proteins
#' (all models were trained using ribosomal proteins as the highly expressed set.)
#' @param mode Whether to run prediction in full, partial, metagenome, or eukaryote mode
#' (by default gRodon applies the full model)
#' @param temperature Optimal growth temperature. By default this is set as
#' "none" for prokaryotes and we do not guarantee good results for non-mesophilic
#'  since prokaryotes few were used to fit the model. For eukaryotes, though, including
#'  an optimal growth temperature drastically improves model predictions as there is
#'  a very strong relationship between OGT and max. growth rate for these organisms.
#' @param training_set Whether to use models trained on the original Vieira-Silva et al.
#' doubling time dataset or doubling times drawn from the Madin et al. database. This
#' setting is only used for prokaryotic modes (eukaryotic models based on their own
#'  training set from Weissman et al. TBD)
#' @param depth_of_coverage When using metagenome mode, provide a vector containing
#' the coverage of your ORFs to improve your estimate
#' @param fragments If using gene fragments predicted from reads, will use a
#' more permissive length filter (120bp as opposed to 240bp)
#' @param genetic_code The genetic code of the organism to be used in codon usage
#' calculations (see https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi). By
#' default code "1" is used for eukaryote mode and code "11" for prokaryotic modes.
#' @return gRodon returns a list with the following elements:
#' \describe{
#'   \item{CUBHE}{Median codon usage bias of the highly expressed genes (MILC)
#'   calculated using the genome-wide codon usage as the expected bias}
#'   \item{ConsistencyHE}{Mean codon usage bias of the highly expressed genes
#'   (MILC) calculated using the codon usage of highly expressed genes as the
#'   expected bias}
#'   \item{CPB}{Genome-wide codon pair bias (Coleman et al. 2008)}
#'   \item{FilteredSequences}{Number of gene sequences filtered out during
#'   calulation (due to length and/or presence of ambiguous bases)}
#'   \item{d}{Predicted doubling time in hours}
#'   \item{LowerCI}{Lower CI of \code{d} (2.5%) from linear model}
#'   \item{UpperCI}{Upper CI of \code{d} (97.5%) from linear model}
#' }
#' @examples
#' # Load in example genome (Streptococcus pyogenes M1, downloaded from RefSeq)
#' # included with gRodon
#' path_to_genome <- system.file('extdata',
#'   'GCF_000349925.2_ASM34992v2_cds_from_genomic.fna.gz',
#'   package = 'gRodon2')
#' genes <- readDNAStringSet(path_to_genome)
#'
#' # Search pre-existing annotations for ribosomal proteins, which we
#' # will use as our set of highly expressed genes
#' highly_expressed <- grepl("ribosomal protein",names(genes),ignore.case = T)
#'
#' # Run the gRodon growth prediction pipeline
#' predictGrowth(genes, highly_expressed)
#'
#' # Run gRodon with temperature option (not needed for mesophiles, gRodon not
#' # validated on extremophiles, use with care)
#' predictGrowth(genes, highly_expressed, temperature = 37)
#'
#' @export
#' @importFrom magrittr "%>%"
#' @importFrom dplyr group_by mutate count summarise
#' @importFrom matrixStats weightedMedian
#' @import coRdon
#' @import Biostrings
predictGrowth <- function(genes,
highly_expressed,
mode = "full",
temperature = "none",
training_set = "vs",
depth_of_coverage = NULL,
fragments = FALSE,
genetic_code = NULL,
bg = "all"){
if(! mode %in% c("full","partial","metagenome","eukaryote","meta_testing","meta_nogc_testing")){
stop("Invalid mode. Please pick an available prediction mode (\"full\", \"partial\", \"metagenome\", \"eukaryote\")")
}
if((! training_set  %in% c("vs","madin")) & mode!="eukaryote"){
stop("Invalid training set. Please pick an available model (\"vs\", \"madin\")")
}
if(sum(highly_expressed)<10){
warning("Less than 10 highly expressed genes provided, performance may suffer")
}
if(!(mode %in% c("metagenome","meta_testing","meta_nogc_testing")) & !is.null(depth_of_coverage)){
warning("Ignoring depth_of_coverage because not in metagenome mode")
depth_of_coverage <- NULL
}
if(mode=="metagenome" & is.null(depth_of_coverage)){
warning("Provide depth_of_coverage for your ORFs for a more realistic average community growth rate")
}
if(is.null(genetic_code) & mode=="eukaryote"){
genetic_code <- "1"
} else if(is.null(genetic_code)){
genetic_code <- "11"
} else {
genetic_code <- as.character(genetic_code)
warning("Models were trained with a default genetic code of '1' for eukaryotes and '11' for prokaryotes. See https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi")
}
if(temperature=="none" & mode=="eukaryote"){
warning("For best results for eukaryotes an optimal growth temperature must be provided. Much of the variation in max. growth rate between species is explained by temperature, independent of any diffferences in codon usage.")
}
# Calculate codon data
if(bg=="all"){
codon_stats <- getCodonStatistics(genes = genes,
highly_expressed = highly_expressed,
fragments = fragments,
depth_of_coverage = depth_of_coverage,
genetic_code = genetic_code)
codon_stats$dCUB <- (codon_stats$CUB-codon_stats$CUBHE)/codon_stats$CUB
# Predict growth rate (stored models - sysdata.rda)
if(training_set=="vs" & mode!="eukaryote" & mode!="meta_testing" & mode!="meta_nogc_testing"){
if(temperature == "none" & mode=="full"){
pred <- stats::predict.lm(gRodon_model_base,
newdata = codon_stats,
interval = "confidence")
} else if(temperature == "none" & mode=="metagenome"){
pred <- stats::predict.lm(gRodon_model_meta,
newdata = codon_stats,
interval = "confidence")
} else if(temperature == "none" & mode=="partial"){
pred <- stats::predict.lm(gRodon_model_partial,
newdata = codon_stats,
interval = "confidence")
} else if(temperature != "none" & mode=="full"){
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_temp,
newdata = codon_stats,
interval = "confidence")
} else if(temperature != "none" & mode=="metagenome"){
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_meta_temp,
newdata = codon_stats,
interval = "confidence")
} else if(temperature != "none" & mode=="partial"){
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_partial_temp,
newdata = codon_stats,
interval = "confidence")
}
#Transform back from box-cox
pred_back_transformed <- boxcoxTransform(pred,
lambda_milc,
back_transform = TRUE)
} else if(mode!="eukaryote" & mode!="meta_testing" & mode!="meta_nogc_testing"){
if(temperature == "none" & mode=="full"){
pred <- stats::predict.lm(gRodon_model_base_madin,
newdata = codon_stats,
interval = "confidence")
} else if(temperature == "none" & mode=="metagenome"){
pred <- stats::predict.lm(gRodon_model_meta_madin,
newdata = codon_stats,
interval = "confidence")
} else if(temperature == "none" & mode=="partial"){
pred <- stats::predict.lm(gRodon_model_partial_madin,
newdata = codon_stats,
interval = "confidence")
} else if(temperature != "none" & mode=="full"){
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_temp_madin,
newdata = codon_stats,
interval = "confidence")
} else if(temperature != "none" & mode=="metagenome"){
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_meta_temp_madin,
newdata = codon_stats,
interval = "confidence")
} else if(temperature != "none" & mode=="partial"){
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_partial_temp_madin,
newdata = codon_stats,
interval = "confidence")
}
#Transform back from box-cox
pred_back_transformed <- boxcoxTransform(pred,
lambda_milc_madin,
back_transform = TRUE)
} else if(mode=="eukaryote"){
if(temperature == "none"){
pred <- stats::predict.lm(gRodon_model_base_euk,
newdata = codon_stats,
interval = "confidence")
} else {
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_temp_euk,
newdata = codon_stats,
interval = "confidence")
}
#Transform back from box-cox
pred_back_transformed <- boxcoxTransform(pred,
lambda_milc_euk,
back_transform = TRUE)
} else if(mode=="meta_testing"){
if(temperature == "none"){
pred <- stats::predict.lm(gRodon_model_newmeta,
newdata = codon_stats,
interval = "confidence")
} else {
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_newmeta_temp,
newdata = codon_stats,
interval = "confidence")
}
#Transform back from box-cox
pred_back_transformed <- boxcoxTransform(pred,
lambda_newmeta,
back_transform = TRUE)
} else if(mode=="meta_nogc_testing"){
if(temperature == "none"){
pred <- stats::predict.lm(gRodon_model_newmeta_nogc,
newdata = codon_stats,
interval = "confidence")
} else {
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_newmeta_nogc_temp,
newdata = codon_stats,
interval = "confidence")
}
#Transform back from box-cox
pred_back_transformed <- boxcoxTransform(pred,
lambda_newmeta,
back_transform = TRUE)
}
} else if(bg=="individual"){
if(!(mode %in% c("meta_testing","meta_nogc_testing"))){
stop("Mode not compatible with gene-level CUB calculations")
}
codon_stats <- getCodonStatistics_i(genes = genes,
highly_expressed = highly_expressed,
fragments = fragments,
depth_of_coverage = depth_of_coverage,
genetic_code = genetic_code)
codon_stats$dCUB <- (codon_stats$CUB-codon_stats$CUBHE)/codon_stats$CUB
if(mode=="meta_testing"){
if(temperature == "none"){
pred <- stats::predict.lm(gRodon_model_newmeta_i,
newdata = codon_stats,
interval = "confidence")
} else {
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_newmeta_temp_i,
newdata = codon_stats,
interval = "confidence")
}
#Transform back from box-cox
pred_back_transformed <- boxcoxTransform(pred,
lambda_newmeta_i,
back_transform = TRUE)
} else if(mode=="meta_nogc_testing"){
if(temperature == "none"){
pred <- stats::predict.lm(gRodon_model_newmeta_nogc_i,
newdata = codon_stats,
interval = "confidence")
} else {
codon_stats$OGT <- temperature
pred <- stats::predict.lm(gRodon_model_newmeta_nogc_temp_i,
newdata = codon_stats,
interval = "confidence")
}
#Transform back from box-cox
pred_back_transformed <- boxcoxTransform(pred,
lambda_newmeta_i,
back_transform = TRUE)
}
} else{
stop("Feature in testing, please set bg==\"all\" for normal gRodon behavior")
}
#attach prediction
codon_stats$d <- pred_back_transformed[,"fit"]
codon_stats$LowerCI <- pred_back_transformed[,"lwr"]
codon_stats$UpperCI <- pred_back_transformed[,"upr"]
#Return
if(is.na(pred_back_transformed[,"fit"]) & pred[,"fit"]>6){
warning("Estimated doubling time very long. Essentially goes to infinity (gives NA value after back-transforming from box-cox).")
} else if(pred_back_transformed[,"fit"]>5 & mode!="eukaryote"){
warning("Estimated doubling time >5 hours. CUB signal saturates at approx. 5 hrs... gRodon may underestimate doubling times above this range. Consider simply reporting as '>5hrs'. (In other words, this microbe definitely grows slowly, but we can't tell you quite how slowly).")
} else if(pred_back_transformed[,"fit"]>40 & mode=="eukaryote"){
warning("Estimated doubling time >40 hours. CUB signal saturates at approx. 40 hrs for eukaryotes... gRodon may underestimate doubling times above this range. Consider simply reporting as '>40hrs'. (In other words, this microbe definitely grows slowly, but we can't tell you quite how slowly).")
}
return(as.list(codon_stats))
}
fitModels(stat_data, stat_data_extremo)
View(stat_data_extremo)
#' Fit gRodon GC-corrected models
#'
#' This function fits the gRodon GC-corrected metagenome mode models
#'
#' @param stat_data dataframe with codon usage statistics and known doubling times
fitGCModels <- function(stat_data, stat_data_extremo){
stat_data <- stat_data %>%
mutate(dCUB=(CUB-CUBHE)/CUB)
stat_data_extremo <- stat_data_extremo %>%
mutate(dCUB=(CUB-CUBHE)/CUB)
bc_meta <- boxcox(d~dCUB+GCdiv,data=stat_data)
lambda_meta <- bc_meta$x[which.max(bc_meta$y)]
#new metagenome mode
meta_model_base <-
lm(boxcoxTransform(d, lambda_meta) ~ dCUB+GCdiv,data=stat_data)
meta_model_temp <-
lm(boxcoxTransform(d, lambda_meta) ~ dCUB+GCdiv+OGT,data=stat_data_extremo)
#new metagenome mode without gc cor
meta_nogc_model_base <-
lm(boxcoxTransform(d, lambda_meta) ~ dCUB,data=stat_data)
meta_nogc_model_temp <-
lm(boxcoxTransform(d, lambda_meta) ~ dCUB+OGT,data=stat_data_extremo)
#old metagenome mode (for individual-gene fitting)
bc_oldmeta <- boxcox(d~CUBHE,data=stat_data)
lambda_oldmeta <- bc_oldmeta$x[which.max(bc_oldmeta$y)]
meta_old_model_base <-
lm(boxcoxTransform(d, lambda_oldmeta) ~ CUBHE,data=stat_data)
meta_old_model_temp <-
lm(boxcoxTransform(d, lambda_oldmeta) ~ CUBHE+OGT,data=stat_data_extremo)
return(list(meta_model_base,
meta_model_temp,
meta_nogc_model_base,
meta_nogc_model_temp,
lambda_meta,
meta_old_model_base,
meta_model_temp,
lambda_oldmeta))
}
model_list <- gRodon:::fitGCModels(stat_data, stat_data_extremo)
model_list <- fitGCModels(stat_data, stat_data_extremo)
gRodon_model_newmeta_i <- model_list[[1]]
gRodon_model_newmeta_temp_i <- model_list[[2]]
gRodon_model_newmeta_nogc_i <- model_list[[3]]
gRodon_model_newmeta_nogc_temp_i <- model_list[[4]]
lambda_newmeta_i <- model_list[[5]]
gRodon_model_meta_madin_i <- model_list[[6]]
gRodon_model_meta_temp_madin_i <- model_list[[7]]
lambda_milc_madin_i <- model_list[[8]]
summary(gRodon_model_meta_madin_i)
summary(gRodon_model_newmeta_nogc_i)
summary(gRodon_model_newmeta_i)
setwd("~/gRodon2/R/")
load("sysdata.rda")
save(gRodon_model_base_madin,
gRodon_model_temp_madin,
gRodon_model_partial_madin,
gRodon_model_partial_temp_madin,
gRodon_model_meta_madin,
gRodon_model_meta_temp_madin,
lambda_milc_madin,
gRodon_model_base,
gRodon_model_temp,
gRodon_model_partial,
gRodon_model_partial_temp,
gRodon_model_meta,
gRodon_model_meta_temp,
lambda_milc,
gRodon_model_newmeta,
gRodon_model_newmeta_temp,
gRodon_model_newmeta_nogc,
gRodon_model_newmeta_nogc_temp,
lambda_newmeta,
gRodon_model_meta_madin_i,
gRodon_model_meta_temp_madin_i,
lambda_milc_madin_i,
gRodon_model_newmeta_i,
gRodon_model_newmeta_temp_i,
gRodon_model_newmeta_nogc_i,
gRodon_model_newmeta_nogc_temp_i,
lambda_newmeta_i,
file="sysdata.rda")
build()
devtools::build()
devtools::build()
load_all()
devtools::load_all()
?predictGrowth()
devtools::document()
devtools::build()
devtools::check()
devtools::document()
devtools::build()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::load_all()
?predictGrowth
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
getwd()
source("~/gRodon2/R/codon_pair_bias.R")
source("~/gRodon2/R/codon_usage_bias.R")
source("~/gRodon2/R/fit_gRodon.R")
source("~/gRodon2/R/fit_gRodon.R")
source("~/gRodon2/R/predict_growth.R")
source("~/gRodon2/R/utilities.R")
library(dplyr)
library(data.table)
library(MASS)
library(gRodon)
library(parallel)
library(Biostrings)
library(coRdon)
library(matrixStats)
# Helper Functions -------------------------------------------------------------
merge.easy <- function(df1,df2,key){
df1 <- data.table(df1,key=key)
df2 <- data.table(df2,key=key)
return(unique(merge(df1,df2,all.x=TRUE,by=.EACHI,allow.cartesian=TRUE)))
}
rgrep <- function(big,small_vec){
small_vec[lapply(small_vec,grepl,x=big) %>% unlist()]
}
cui <- getStatisticsBatch("~/gRodon2/inst/extdata/euk_genomes/",
genetic_code = "1",
mc.cores = 1,
bg = "individual")
devtools::document()
devtools::load_all()
devtools::document()
devtools::check()
devtools::build()
load("~/gRodon2/R/sysdata.rda")
summary(gRodon_model_base_euk)
summary(gRodon_model_temp_euk)
